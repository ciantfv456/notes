"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};

// index.ts






var _fs = require('fs');
var _path = require('path');
var _child_process = require('child_process');
var _crossfetch = require('cross-fetch'); var _crossfetch2 = _interopRequireDefault(_crossfetch);
var konan = __require("konan");
var url = "https://nodejs.org/docs/latest/api/documentation.json";
function getDepends(path, extend) {
  const fileList = [];
  const depends = [];
  function findFile(path2) {
    const files = _fs.readdirSync.call(void 0, path2);
    files.forEach((item) => {
      const fPath = _path.join.call(void 0, path2, item);
      const stat = _fs.statSync.call(void 0, fPath);
      if (stat.isDirectory() === true && item !== "node_modules") {
        findFile(fPath);
      }
      const newExtend = extend.map((ext) => item.endsWith("." + ext));
      if (stat.isFile() === true && newExtend.includes(true)) {
        fileList.push(fPath);
      }
    });
  }
  findFile(path);
  fileList.forEach((item) => {
    depends.push(...konan(_fs.readFileSync.call(void 0, item, "utf-8")).strings);
  });
  return Array.from(new Set(depends));
}
var requireResolver = async (path, attach = {}, npmClient = "npm", excludeOption = ["dependencies", "devDependencies", "scripts"], extend = ["js", "mjs", "cjs", "ts", "jsx"], silent = false) => {
  const pprint = (...content2) => {
    if (!silent)
      console.log("[ dependencies-resolver ] ", ...content2);
  };
  const dependencyJson = {};
  pprint("Fetch built-in modules list from npm...");
  const content = await (await _crossfetch2.default.call(void 0, url)).json();
  const table = content.miscs[0].miscs.filter((item) => item.name === "stability_overview")[0].desc;
  const internelModules = table.match(/<a href=(.*?)>/g).map((item) => item.slice(9, -7));
  pprint("Resolving dependencies...");
  const toinstall = getDepends(path, extend).filter((item) => !(item.startsWith("./") || item.startsWith("../"))).filter((item) => !internelModules.includes(item));
  const pkgJsonPath = _path.resolve.call(void 0, path, "package.json");
  let pkgJson = {};
  let pkgDependencies = {};
  if (_fs.existsSync.call(void 0, pkgJsonPath)) {
    pkgJson = JSON.parse(_fs.readFileSync.call(void 0, pkgJsonPath, "utf-8"));
    if (pkgJson["dependencies"]) {
      pkgDependencies = pkgJson["dependencies"];
    }
    excludeOption.forEach((item) => {
      if (pkgJson[item]) {
        delete pkgJson[item];
      }
    });
  }
  toinstall.forEach((dependency) => {
    let version = "*";
    if (Object.keys(pkgDependencies).includes(dependency)) {
      version = pkgDependencies[dependency];
    }
    dependencyJson[dependency] = version;
  });
  Object.keys(attach).forEach((dependency) => {
    dependencyJson[dependency] = attach[dependency];
  });
  pkgJson["dependencies"] = dependencyJson;
  pprint("Find dependencies: ", JSON.stringify(dependencyJson, null, 2).replace("{", "").replace("}", ""));
  _fs.writeFileSync.call(void 0, pkgJsonPath, JSON.stringify(pkgJson));
  const currentPath = _path.resolve.call(void 0, );
  process.chdir(path);
  pprint("Installing dependencies...");
  pprint(_child_process.execSync.call(void 0, `${npmClient} install`).toString("utf-8"));
  pprint("Deduping dependencies...");
  pprint(_child_process.execSync.call(void 0, `${npmClient} dedupe --production`).toString("utf-8"));
  process.chdir(currentPath);
  return dependencyJson;
};
var dependencies_resolver_default = requireResolver;



exports.default = dependencies_resolver_default; exports.getDepends = getDepends;
