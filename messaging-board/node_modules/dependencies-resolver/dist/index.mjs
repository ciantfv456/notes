var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};

// index.ts
import {
  existsSync,
  writeFileSync,
  readFileSync,
  readdirSync,
  statSync
} from "fs";
import {join, resolve} from "path";
import {execSync} from "child_process";
import fetch from "cross-fetch";
var konan = __require("konan");
var url = "https://nodejs.org/docs/latest/api/documentation.json";
function getDepends(path, extend) {
  const fileList = [];
  const depends = [];
  function findFile(path2) {
    const files = readdirSync(path2);
    files.forEach((item) => {
      const fPath = join(path2, item);
      const stat = statSync(fPath);
      if (stat.isDirectory() === true && item !== "node_modules") {
        findFile(fPath);
      }
      const newExtend = extend.map((ext) => item.endsWith("." + ext));
      if (stat.isFile() === true && newExtend.includes(true)) {
        fileList.push(fPath);
      }
    });
  }
  findFile(path);
  fileList.forEach((item) => {
    depends.push(...konan(readFileSync(item, "utf-8")).strings);
  });
  return Array.from(new Set(depends));
}
var requireResolver = async (path, attach = {}, npmClient = "npm", excludeOption = ["dependencies", "devDependencies", "scripts"], extend = ["js", "mjs", "cjs", "ts", "jsx"], silent = false) => {
  const pprint = (...content2) => {
    if (!silent)
      console.log("[ dependencies-resolver ] ", ...content2);
  };
  const dependencyJson = {};
  pprint("Fetch built-in modules list from npm...");
  const content = await (await fetch(url)).json();
  const table = content.miscs[0].miscs.filter((item) => item.name === "stability_overview")[0].desc;
  const internelModules = table.match(/<a href=(.*?)>/g).map((item) => item.slice(9, -7));
  pprint("Resolving dependencies...");
  const toinstall = getDepends(path, extend).filter((item) => !(item.startsWith("./") || item.startsWith("../"))).filter((item) => !internelModules.includes(item));
  const pkgJsonPath = resolve(path, "package.json");
  let pkgJson = {};
  let pkgDependencies = {};
  if (existsSync(pkgJsonPath)) {
    pkgJson = JSON.parse(readFileSync(pkgJsonPath, "utf-8"));
    if (pkgJson["dependencies"]) {
      pkgDependencies = pkgJson["dependencies"];
    }
    excludeOption.forEach((item) => {
      if (pkgJson[item]) {
        delete pkgJson[item];
      }
    });
  }
  toinstall.forEach((dependency) => {
    let version = "*";
    if (Object.keys(pkgDependencies).includes(dependency)) {
      version = pkgDependencies[dependency];
    }
    dependencyJson[dependency] = version;
  });
  Object.keys(attach).forEach((dependency) => {
    dependencyJson[dependency] = attach[dependency];
  });
  pkgJson["dependencies"] = dependencyJson;
  pprint("Find dependencies: ", JSON.stringify(dependencyJson, null, 2).replace("{", "").replace("}", ""));
  writeFileSync(pkgJsonPath, JSON.stringify(pkgJson));
  const currentPath = resolve();
  process.chdir(path);
  pprint("Installing dependencies...");
  pprint(execSync(`${npmClient} install`).toString("utf-8"));
  pprint("Deduping dependencies...");
  pprint(execSync(`${npmClient} dedupe --production`).toString("utf-8"));
  process.chdir(currentPath);
  return dependencyJson;
};
var dependencies_resolver_default = requireResolver;
export {
  dependencies_resolver_default as default,
  getDepends
};
